"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const cli_framework_1 = require("@ionic/cli-framework");
const chalk_1 = require("chalk");
const path = require("path");
const guards_1 = require("../../guards");
const errors_1 = require("../errors");
var guards_2 = require("../../guards");
exports.INTEGRATION_NAMES = guards_2.INTEGRATION_NAMES;
class IntegrationConfig extends cli_framework_1.BaseConfig {
    provideDefaults(c) {
        return {};
    }
}
exports.IntegrationConfig = IntegrationConfig;
class BaseIntegration {
    constructor(e) {
        this.e = e;
    }
    static createFromName(deps, name) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            if (guards_1.isIntegrationName(name)) {
                const { Integration } = yield Promise.resolve().then(() => require(`./${name}`));
                return new Integration(deps);
            }
            throw new errors_1.IntegrationNotFoundException(`Bad integration name: ${chalk_1.default.bold(name)}`); // TODO?
        });
    }
    getInfo() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            return [];
        });
    }
    isAdded() {
        return !!this.e.project.config.get('integrations')[this.name];
    }
    isEnabled() {
        const integrationConfig = this.e.project.config.get('integrations')[this.name];
        return !!integrationConfig && integrationConfig.enabled !== false;
    }
    enable(config) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            if (config && config.root) {
                this.config.set('root', config.root);
            }
            this.config.unset('enabled');
        });
    }
    disable() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            this.config.set('enabled', false);
        });
    }
    personalize(details) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            // optionally overwritten by subclasses
        });
    }
    add(details) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const config = details.root !== this.e.project.directory ?
                { root: path.relative(this.e.project.rootDirectory, details.root) } :
                undefined;
            yield this.enable(config);
        });
    }
}
exports.BaseIntegration = BaseIntegration;
