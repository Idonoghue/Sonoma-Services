"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const utils_fs_1 = require("@ionic/utils-fs");
const chalk_1 = require("chalk");
const Debug = require("debug");
const lodash = require("lodash");
const os = require("os");
const path = require("path");
const __1 = require("../");
const debug = Debug('ionic:lib:integrations:cordova');
class Integration extends __1.BaseIntegration {
    constructor() {
        super(...arguments);
        this.name = 'cordova';
        this.summary = 'Target native iOS and Android with Apache Cordova';
        this.archiveUrl = 'https://d2ql0qc7j8u4b2.cloudfront.net/integration-cordova.tar.gz';
    }
    get config() {
        return new __1.IntegrationConfig(this.e.project.filePath, { pathPrefix: ['integrations', this.name] });
    }
    add(details) {
        const _super = Object.create(null, {
            add: { get: () => super.add }
        });
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const handlers = {
                conflictHandler: (f, stats) => tslib_1.__awaiter(this, void 0, void 0, function* () {
                    const isDirectory = stats.isDirectory();
                    const filename = `${path.basename(f)}${isDirectory ? '/' : ''}`;
                    const type = isDirectory ? 'directory' : 'file';
                    const confirm = yield details.env.prompt({
                        type: 'confirm',
                        name: 'confirm',
                        message: `The ${chalk_1.default.cyan(filename)} ${type} exists in project. Overwrite?`,
                        default: false,
                    });
                    return confirm;
                }),
                onFileCreate: f => {
                    if (!details.quiet) {
                        details.env.log.msg(`${chalk_1.default.green('CREATE')} ${f}`);
                    }
                },
            };
            const onFileCreate = handlers.onFileCreate ? handlers.onFileCreate : lodash.noop;
            const conflictHandler = handlers.conflictHandler ? handlers.conflictHandler : () => tslib_1.__awaiter(this, void 0, void 0, function* () { return false; });
            const { createRequest, download } = yield Promise.resolve().then(() => require('../../utils/http'));
            const { tar } = yield Promise.resolve().then(() => require('../../utils/archive'));
            this.e.log.info(`Downloading integration ${chalk_1.default.green(this.name)}`);
            const tmpdir = path.resolve(os.tmpdir(), `ionic-integration-${this.name}`);
            // TODO: etag
            if (yield utils_fs_1.pathExists(tmpdir)) {
                yield utils_fs_1.remove(tmpdir);
            }
            yield utils_fs_1.mkdirp(tmpdir);
            const ws = tar.extract({ cwd: tmpdir });
            const { req } = yield createRequest('GET', this.archiveUrl, this.e.config.getHTTPConfig());
            yield download(req, ws, {});
            const contents = yield utils_fs_1.readdirSafe(tmpdir);
            const blacklist = [];
            debug(`Integration files downloaded to ${chalk_1.default.bold(tmpdir)} (files: ${contents.map(f => chalk_1.default.bold(f)).join(', ')})`);
            for (const f of contents) {
                const projectf = path.resolve(this.e.project.directory, f);
                try {
                    const stats = yield utils_fs_1.stat(projectf);
                    const overwrite = yield conflictHandler(projectf, stats);
                    if (!overwrite) {
                        blacklist.push(f);
                    }
                }
                catch (e) {
                    if (e.code !== 'ENOENT') {
                        throw e;
                    }
                }
            }
            this.e.log.info(`Copying integrations files to project`);
            debug(`Blacklist: ${blacklist.map(f => chalk_1.default.bold(f)).join(', ')}`);
            yield utils_fs_1.mkdirp(details.root);
            yield utils_fs_1.copy(tmpdir, details.root, {
                filter: f => {
                    if (f === tmpdir) {
                        return true;
                    }
                    const projectf = f.substring(tmpdir.length + 1);
                    for (const item of blacklist) {
                        if (item.slice(-1) === '/' && `${projectf}/` === item) {
                            return false;
                        }
                        if (projectf.startsWith(item)) {
                            return false;
                        }
                    }
                    onFileCreate(projectf);
                    return true;
                },
            });
            yield _super.add.call(this, details);
        });
    }
    getInfo() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const { getAndroidSdkToolsVersion } = yield Promise.resolve().then(() => require('./android'));
            const [cordovaVersion, cordovaPlatforms, cordovaPlugins, xcode, iosDeploy, iosSim, androidSdkToolsVersion,] = yield Promise.all([
                this.getCordovaVersion(),
                this.getCordovaPlatformVersions(),
                this.getCordovaPluginVersions(),
                this.getXcodebuildVersion(),
                this.getIOSDeployVersion(),
                this.getIOSSimVersion(),
                getAndroidSdkToolsVersion(),
            ]);
            const info = [
                { group: 'cordova', key: 'cordova', flair: 'Cordova CLI', value: cordovaVersion || 'not installed' },
                { group: 'cordova', key: 'Cordova Platforms', value: cordovaPlatforms },
                { group: 'cordova', key: 'Cordova Plugins', value: cordovaPlugins },
            ];
            if (xcode) {
                info.push({ group: 'system', key: 'Xcode', value: xcode });
            }
            if (iosDeploy) {
                info.push({ group: 'system', key: 'ios-deploy', value: iosDeploy });
            }
            if (iosSim) {
                info.push({ group: 'system', key: 'ios-sim', value: iosSim });
            }
            if (androidSdkToolsVersion) {
                info.push({ group: 'system', key: 'Android SDK Tools', value: androidSdkToolsVersion });
            }
            return info;
        });
    }
    personalize({ name, packageId }) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const { loadConfigXml } = yield Promise.resolve().then(() => require('./config'));
            const integration = this.e.project.requireIntegration('cordova');
            const conf = yield loadConfigXml(integration);
            conf.setName(name);
            if (packageId) {
                conf.setBundleId(packageId);
            }
            yield conf.save();
        });
    }
    getCordovaVersion() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            try {
                const integration = this.e.project.requireIntegration('cordova');
                return this.e.shell.cmdinfo('cordova', ['-v', '--no-telemetry', '--no-update-notifier'], { cwd: integration.root });
            }
            catch (e) {
                debug('Error while getting Cordova version: %O', e);
            }
        });
    }
    getCordovaPlatformVersions() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            try {
                const integration = this.e.project.requireIntegration('cordova');
                const output = yield this.e.shell.output('cordova', ['platform', 'ls', '--no-telemetry', '--no-update-notifier'], { cwd: integration.root, showCommand: false });
                const platforms = output
                    .replace('Installed platforms:', '')
                    .replace(/Available platforms[\s\S]+/, '')
                    .split('\n')
                    .map(l => l.trim())
                    .filter(l => l && !l.startsWith('.'));
                if (platforms.length === 0) {
                    return 'none';
                }
                return platforms.join(', ');
            }
            catch (e) {
                debug('Error while getting Cordova platforms: %O', e);
                return 'not available';
            }
        });
    }
    getCordovaPluginVersions() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const whitelist = [
                /^cordova-plugin-ionic$/,
                /^cordova-plugin-ionic-.+/,
            ];
            try {
                const integration = this.e.project.requireIntegration('cordova');
                const output = yield this.e.shell.output('cordova', ['plugin', 'ls', '--no-telemetry', '--no-update-notifier'], { cwd: integration.root, showCommand: false });
                const pluginRe = /^([a-z-]+)\s+(\d\.\d\.\d).+$/;
                const plugins = output
                    .split('\n')
                    .map(l => l.trim().match(pluginRe))
                    .filter((l) => l !== null)
                    .map(m => [m[1], m[2]]);
                const whitelistedPlugins = plugins
                    .filter(([plugin, version]) => whitelist.some(re => re.test(plugin)))
                    .map(([plugin, version]) => `${plugin} ${version}`);
                const count = plugins.length - whitelistedPlugins.length;
                if (whitelistedPlugins.length === 0) {
                    return `no whitelisted plugins (${count} plugins total)`;
                }
                return `${whitelistedPlugins.join(', ')}${count > 0 ? `, (and ${count} other plugins)` : ''}`;
            }
            catch (e) {
                debug('Error while getting Cordova plugins: %O', e);
                return 'not available';
            }
        });
    }
    getXcodebuildVersion() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            return this.e.shell.cmdinfo('xcodebuild', ['-version']);
        });
    }
    getIOSDeployVersion() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            return this.e.shell.cmdinfo('ios-deploy', ['--version']);
        });
    }
    getIOSSimVersion() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            return this.e.shell.cmdinfo('ios-sim', ['--version']);
        });
    }
}
exports.Integration = Integration;
