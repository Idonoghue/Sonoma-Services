"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const cli_framework_1 = require("@ionic/cli-framework");
const utils_fs_1 = require("@ionic/utils-fs");
const chalk_1 = require("chalk");
const lodash = require("lodash");
const path = require("path");
const __1 = require("../");
const guards_1 = require("../../../guards");
const errors_1 = require("../../errors");
const CHOICE_CREATE_NEW_APP = 'createNewApp';
class EnterpriseIntegrationConfig extends cli_framework_1.BaseConfig {
    provideDefaults(c) {
        return {};
    }
}
exports.EnterpriseIntegrationConfig = EnterpriseIntegrationConfig;
class Integration extends __1.BaseIntegration {
    constructor() {
        super(...arguments);
        this.name = 'enterprise';
        this.summary = 'Ionic Enterprise Edition provides premier native solutions, UI, & support for companies building cross-platform apps.';
        this.archiveUrl = undefined;
    }
    enable(config) {
        const _super = Object.create(null, {
            enable: { get: () => super.enable }
        });
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const baseConfig = config && config.root ? { root: config.root } : undefined;
            yield this.updateNPMRC();
            return _super.enable.call(this, baseConfig);
        });
    }
    add(details) {
        const _super = Object.create(null, {
            add: { get: () => super.add }
        });
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            let productKey = this.config.get('productKey');
            let appId = this.config.get('appId');
            if (details.enableArgs) {
                const parsedArgs = cli_framework_1.parseArgs(details.enableArgs, { string: ['app-id', 'key'] });
                appId = parsedArgs['app-id'];
                productKey = parsedArgs['key'];
            }
            if (!productKey) {
                productKey = yield details.env.prompt({
                    type: 'input',
                    name: 'product-key',
                    message: 'Please enter your product key:',
                });
            }
            const keyInfo = yield this.validatePK(details, productKey, appId);
            for (const entry of lodash.entries(keyInfo)) {
                const [key, value] = entry;
                this.config.set(key, value);
            }
            return _super.add.call(this, details);
        });
    }
    validatePK(details, pk, appId) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            let key = yield this.getPK(details, pk);
            if (!key.org) {
                throw new errors_1.FatalException('No Organization attached to key. Please contact support@ionic.io');
            }
            if (!key.app || appId) {
                if (!appId) {
                    appId = yield this.chooseAppToLink(details, key.org);
                }
                key = yield this.registerKey(details, key, appId);
            }
            return {
                keyId: key.id,
                productKey: key.key,
                appId: key.app.id,
                orgId: key.org.id,
                registries: key.registries,
            };
        });
    }
    chooseAppToLink(details, org) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const appClient = yield this.getAppClient(details);
            const paginator = appClient.paginate({}, org.id);
            const apps = [];
            for (const r of paginator) {
                const res = yield r;
                apps.push(...res.data);
            }
            let appId = yield this.chooseApp(details, apps, org);
            if (appId === CHOICE_CREATE_NEW_APP) {
                appId = yield this.createNewApp(details, org);
            }
            return appId;
        });
    }
    registerKey(details, key, appId) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const token = details.env.session.getUserToken();
            const { req } = yield details.env.client.make('PATCH', `/orgs/${key.org.id}/keys/${key.id}`);
            req.set('Authorization', `Bearer ${token}`);
            req.send({ app_id: appId });
            try {
                const res = yield details.env.client.do(req);
                return res.data;
            }
            catch (e) {
                if (guards_1.isSuperAgentError(e)) {
                    if (e.response.status === 401 || e.response.status === 403) {
                        throw new errors_1.FatalException('Authorization Failed. Make sure you\'re logged into the correct account with access to the key. Try logging out and back in again.');
                    }
                    const apiErrorMessage = (e.response.body.error && e.response.body.error.message) ? e.response.body.error.message : 'Api Error';
                    throw new errors_1.FatalException(`Unable to Register Key: ` + apiErrorMessage);
                }
                else {
                    throw e;
                }
            }
        });
    }
    getAppClient(details) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const { AppClient } = yield Promise.resolve().then(() => require('../../../lib/app'));
            const token = details.env.session.getUserToken();
            return new AppClient(token, details.env);
        });
    }
    createNewApp(details, org) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const appName = yield details.env.prompt({
                type: 'input',
                name: 'appName',
                message: 'Please enter the name of your app:',
            });
            const appClient = yield this.getAppClient(details);
            const newApp = yield appClient.create({ org_id: org.id, name: appName });
            return newApp.id;
        });
    }
    chooseApp(details, apps, org) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const { formatName } = yield Promise.resolve().then(() => require('../../../lib/app'));
            const newAppChoice = {
                name: chalk_1.default.bold('Create A New App'),
                id: CHOICE_CREATE_NEW_APP,
                value: CHOICE_CREATE_NEW_APP,
                org,
            };
            const linkedApp = yield details.env.prompt({
                type: 'list',
                name: 'linkedApp',
                message: 'This key needs to be registered to an app. Which app would you like to register it to?',
                choices: [
                    ...apps.map(app => ({
                        name: `${formatName(app)} ${chalk_1.default.dim(`(${app.id})`)}`,
                        value: app.id,
                    })),
                    cli_framework_1.createPromptChoiceSeparator(),
                    newAppChoice,
                    cli_framework_1.createPromptChoiceSeparator(),
                ],
            });
            return linkedApp;
        });
    }
    getPK(details, pk) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const token = details.env.session.getUserToken();
            const { req } = yield details.env.client.make('GET', '/keys/self');
            req.set('Authorization', `Bearer ${token}`).set('Product-Key-ID', pk);
            try {
                const res = yield details.env.client.do(req);
                return res.data;
            }
            catch (e) {
                if (guards_1.isSuperAgentError(e)) {
                    if (e.response.status === 401 || e.response.status === 403) {
                        throw new errors_1.FatalException('Authorization Failed. Make sure you\'re logged into the correct account with access to the key. Try logging out and back in again.');
                    }
                    if (e.response.status === 404) {
                        throw new errors_1.FatalException('Invalid Product Key');
                    }
                    const apiErrorMessage = (e.response.body.error && e.response.body.error.message) ? e.response.body.error.message : 'Api Error';
                    throw new errors_1.FatalException(`Unable to Add Integration: ` + apiErrorMessage);
                }
                else {
                    throw e;
                }
            }
        });
    }
    updateNPMRC() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const pk = this.config.get('productKey');
            const registries = this.config.get('registries');
            if (!pk || !registries) {
                throw new errors_1.FatalException('Enterprise config invalid');
            }
            let npmrc = '';
            try {
                npmrc = yield utils_fs_1.readFile(path.join(this.e.project.directory, '.npmrc'), 'utf8');
            }
            catch (e) {
                if (!e.message.includes('ENOENT')) {
                    throw e;
                }
            }
            for (const entry of registries) {
                const [scope, url] = entry.split(';');
                const urlNoProt = url.split(':').splice(1).join(':');
                const scopeRegex = new RegExp(`${scope}:registry.*\\n?`, 'g');
                const urlRegex = new RegExp(`${urlNoProt}:_authToken.*\\n?`, 'g');
                const newScope = `${scope}:registry=${url}\n`;
                const newUrl = `${urlNoProt}:_authToken=${pk}\n`;
                if (npmrc.match(scopeRegex)) {
                    npmrc = npmrc.replace(scopeRegex, newScope);
                }
                else {
                    npmrc += newScope;
                }
                if (npmrc.match(urlRegex)) {
                    npmrc = npmrc.replace(urlRegex, newUrl);
                }
                else {
                    npmrc += newUrl;
                }
            }
            yield utils_fs_1.writeFile(path.join(this.e.project.directory, `.npmrc`), npmrc, { encoding: 'utf8' });
        });
    }
    get config() {
        return new EnterpriseIntegrationConfig(this.e.project.filePath, { pathPrefix: ['integrations', this.name] });
    }
}
exports.Integration = Integration;
